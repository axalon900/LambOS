#pragma once

#include <cstddef>

namespace std {

// ====================================================
// Forward declarations
// ====================================================

template<typename, unsigned = 0> struct extent;
template<typename T> struct is_array;
template<typename T> struct is_function;

// ====================================================
// SFINAE and conditionals
// ====================================================

template<typename T, T _value>
struct integral_constant
{
    using type = integral_constant;
    using value_type = T;
    static constexpr inline T value = _value;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template <bool Value> using bool_constant = std::integral_constant<bool, Value>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

template <typename T> struct identity { using type = T; };

struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    void operator=(nonesuch const&) = delete;
};

// conditional

//template<bool Pred, typename Then, typename Else>
//struct conditional { using type = Then; };
//
//template<typename Then, typename Else>
//struct conditional<false, Then, Else> { using type = Else; };

// compiles way faster/generates less symbols than above
template <bool Cond> struct _conditional_impl { template <typename Then, typename Else> using type = identity<Then>; };
template <> struct _conditional_impl<false> { template <typename Then, typename Else> using type = identity<Else>; };

template <bool Cond, typename Then, typename Else>
using conditional = typename _conditional_impl<Cond>::template type<Then, Else>;

template <bool Cond, typename Then, typename Else>
using conditional_t = typename conditional<Cond, Then, Else>::type;

template<typename...> struct conjunction : std::true_type {};
template<typename B1> struct conjunction<B1> : B1 {};
template<class B1, class... Bn> struct conjunction<B1, Bn...> : conditional_t<bool(B1::value), conjunction<Bn...>, B1> {};

template<typename...> struct disjunction : std::false_type {};
template<typename B1> struct disjunction<B1> : B1 {};
template<class B1, class... Bn> struct disjunction<B1, Bn...> : conditional_t<bool(B1::value), B1, disjunction<Bn...>> {};

template<typename B> using negation = bool_constant<!bool(B::value)>;

// all_false [nonstandard]
template <typename... Bs> using all_false = negation<disjunction<Bs...>>;

// enable_if
template <bool, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

template<typename T, typename...> using erase_t = T;
template<typename...> using void_t = void;
template<typename...> struct __pack_t {};

// detector [nonstandard]
template <class Default, class AlwaysVoid, template<class...> class Op, class... Args>
struct detector : identity<Default> { using value_t = std::false_type; };

template <class Default, template<class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...> : identity<Op<Args...>> { using value_t = std::true_type; };

template <template<class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template <template<class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template <class Default, template<class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template <template<class...> class Op, class... Args>
constexpr inline bool is_detected_v = is_detected<Op, Args...>::value;

// is_same
template <typename, typename> struct is_same : public false_type {};
template <typename T> struct is_same<T, T> : public true_type {};

// is_any_of [nonstandard]
template <typename T, typename... Rs> using is_any_of = disjunction<is_same<T, Rs>...>;

// ====================================================
// Type transformations
// ====================================================

// remove_extent
template<typename T> struct remove_extent { using type = T; };
template<typename T> struct remove_extent<T[]> { using type = T; };
template<typename T, size_t N> struct remove_extent<T[N]> { using type = T; };
template<typename T> using remove_extent_t = typename remove_extent<T>::type;

// remove_reference
template <typename T> struct remove_reference      { using type = T; };
template <typename T> struct remove_reference<T&>  { using type = T; };
template <typename T> struct remove_reference<T&&> { using type = T; };
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

// remove_const
template<typename T> struct remove_const { using type = T; };
template<typename T> struct remove_const<const T> { using type = T; };
template<typename T> using remove_const_t = typename remove_const<T>::type;

// remove_volatile
template<typename T> struct remove_volatile { using type = T; };
template<typename T> struct remove_volatile<volatile T> { using type = T; };
template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;

// remove_cv
template<typename T> struct remove_cv { using type = std::remove_volatile_t<typename std::remove_const_t<T>>; };
template<typename T> using remove_cv_t = typename remove_cv<T>::type;

// remove_cvref
template<typename T> struct remove_cvref { using type = std::remove_cv_t<std::remove_reference_t<T>>; };
template<typename T> using remove_cvref_t = typename remove_cvref<T>::type;

// remove_pointer
template<typename T> struct remove_pointer { using type = T; };
template<typename T> struct remove_pointer<T*> { using type = T; };
template<typename T> using remove_pointer_t = typename remove_pointer<T>::type;

// remove_all_extents
template<typename T> struct remove_all_extents { using type = T; };
template <typename T> using remove_all_extents_t = typename remove_all_extents<T>::type;

template<typename T, std::size_t Size> struct remove_all_extents<T[Size]> { using type = remove_all_extents_t<T>; };
template<typename T> struct remove_all_extents<T[]> { using type = remove_all_extents_t<T>; };

// add_lvalue_Reference
template <typename T> using add_lvalue_reference = identity<T&>;
template <typename T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

static_assert(is_same<add_lvalue_reference_t<bool>            , bool&>::value);
static_assert(is_same<add_lvalue_reference_t<bool &>          , bool&>::value);
static_assert(is_same<add_lvalue_reference_t<bool &&>         , bool&>::value);
static_assert(is_same<add_lvalue_reference_t<bool const>      , bool const&>::value);
static_assert(is_same<add_lvalue_reference_t<bool const &>    , bool const&>::value);
static_assert(is_same<add_lvalue_reference_t<bool const &&>   , bool const&>::value);
static_assert(is_same<add_lvalue_reference_t<bool volatile>   , bool volatile &>::value);
static_assert(is_same<add_lvalue_reference_t<bool volatile &> , bool volatile &>::value);
static_assert(is_same<add_lvalue_reference_t<bool volatile &&>, bool volatile &>::value);

// add_rvalue_reference
template <typename T> using add_rvalue_reference = identity<T&&>;
template <typename T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

static_assert(is_same<add_rvalue_reference_t<bool>            , bool &&>::value);
static_assert(is_same<add_rvalue_reference_t<bool &>          , bool &>::value);
static_assert(is_same<add_rvalue_reference_t<bool &&>         , bool &&>::value);
static_assert(is_same<add_rvalue_reference_t<bool const>      , bool const &&>::value);
static_assert(is_same<add_rvalue_reference_t<bool const &>    , bool const &>::value);
static_assert(is_same<add_rvalue_reference_t<bool const &&>   , bool const &&>::value);
static_assert(is_same<add_rvalue_reference_t<bool volatile>   , bool volatile &&>::value);
static_assert(is_same<add_rvalue_reference_t<bool volatile &> , bool volatile &>::value);
static_assert(is_same<add_rvalue_reference_t<bool volatile &&>, bool volatile &&>::value);

// add_const
template <typename T> using add_const = identity<T const>;
template <typename T> using add_const_t = typename add_const<T>::type;

static_assert(is_same<add_const_t<bool>            , bool const>::value);
static_assert(is_same<add_const_t<bool &>          , bool &>::value);
static_assert(is_same<add_const_t<bool &&>         , bool &&>::value);
static_assert(is_same<add_const_t<bool const>      , bool const>::value);
static_assert(is_same<add_const_t<bool const &>    , bool const &>::value);
static_assert(is_same<add_const_t<bool const &&>   , bool const &&>::value);
static_assert(is_same<add_const_t<bool volatile>   , bool volatile const>::value);
static_assert(is_same<add_const_t<bool volatile &> , bool volatile &>::value);
static_assert(is_same<add_const_t<bool volatile &&>, bool volatile &&>::value);

// add_volatile
template<typename T> using add_volatile = identity<T volatile>;
template <typename T> using add_volatile_t = typename add_volatile<T>::type;

static_assert(is_same<add_volatile_t<bool>            , bool volatile>::value);
static_assert(is_same<add_volatile_t<bool&>           , bool &>::value);
static_assert(is_same<add_volatile_t<bool&&>          , bool &&>::value);
static_assert(is_same<add_volatile_t<bool volatile>   , bool volatile>::value);
static_assert(is_same<add_volatile_t<bool volatile &> , bool volatile &>::value);
static_assert(is_same<add_volatile_t<bool volatile &&>, bool volatile &&>::value);
static_assert(is_same<add_volatile_t<bool const>      , bool volatile const>::value);
static_assert(is_same<add_volatile_t<bool const &>    , bool const &>::value);
static_assert(is_same<add_volatile_t<bool const &&>   , bool const &&>::value);

// add_cv
template<typename T> using add_cv = add_const<add_volatile_t<T>>;
template <typename T> using add_cv_t = typename add_cv<T>::type;

static_assert(is_same<add_cv_t<bool>                  , bool volatile const>::value);
static_assert(is_same<add_cv_t<bool &>                , bool &>::value);
static_assert(is_same<add_cv_t<bool &&>               , bool &&>::value);
static_assert(is_same<add_cv_t<bool const>            , bool volatile const>::value);
static_assert(is_same<add_cv_t<bool const &>          , bool const &>::value);
static_assert(is_same<add_cv_t<bool const &&>         , bool const &&>::value);
static_assert(is_same<add_cv_t<bool volatile>         , bool volatile const>::value);
static_assert(is_same<add_cv_t<bool volatile &>       , bool volatile &>::value);
static_assert(is_same<add_cv_t<bool volatile &&>      , bool volatile &&>::value);
static_assert(is_same<add_cv_t<bool volatile const>   , bool volatile const>::value);
static_assert(is_same<add_cv_t<bool volatile const &> , bool volatile const &>::value);
static_assert(is_same<add_cv_t<bool volatile const &&>, bool volatile const &&>::value);

// [nonstandard] conditional application of cv qualification
template <typename T, bool C> using apply_const_t = conditional_t<C, add_const_t<T>, T>;
template <typename T, bool V> using apply_volatile_t = conditional_t<V, add_volatile_t<T>, T>;
template <typename T, bool C, bool V> using apply_cv_t = apply_const_t<apply_volatile_t<T, V>, C>;

// add_pointer
template<typename T> struct add_pointer { using type = typename std::remove_reference_t<T>*; };
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

template <typename T> class decay
{
    using U = remove_reference_t<T>;
  public:
    using type = conditional_t<is_array<U>::value, remove_extent_t<U>*,
                               conditional_t<is_function<U>::value, add_pointer_t<U>, remove_cv_t<U>>>;
};
template <typename T> using decay_t = typename std::decay<T>::type;

// ====================================================
// Type traits
// ====================================================

template<typename T> typename add_rvalue_reference<T>::type declval() noexcept;

// is_const
template<typename> struct is_const : public false_type {};
template<typename T> struct is_const<const T> : public true_type {};

// is_volatile
template<typename> struct is_volatile : public false_type {};
template<typename T> struct is_volatile<T volatile> : public true_type {};

// is_lvalue_reference
template<typename> struct is_lvalue_reference : public false_type {};
template<typename T> struct is_lvalue_reference<T&> : public true_type {};

// is_rvalue_reference
template<typename> struct is_rvalue_reference : public false_type {};
template<typename T> struct is_rvalue_reference<T&&> : public true_type {};

template<typename T>
struct is_reference : public disjunction<is_lvalue_reference<T>,
                                         is_rvalue_reference<T>>::type {};

template<typename T> struct is_enum : public bool_constant<__is_enum(T)> {};
template<typename T> struct is_union : public bool_constant<__is_union(T)> {};
template<typename T> struct is_class : public bool_constant<__is_class(T)> {};

// is_pointer
template<typename> struct _is_pointer_impl : public false_type {};
template<typename T> struct _is_pointer_impl<T*> : public true_type {};

template<typename T> struct is_pointer : public _is_pointer_impl<typename remove_cv<T>::type>::type {};

// is_null_pointer
template<typename> struct _is_null_pointer_impl : public false_type {};
template<> struct _is_null_pointer_impl<decltype(nullptr)> : public true_type {};
template<typename T> struct is_null_pointer : public _is_null_pointer_impl<typename remove_cv<T>::type>::type {};

// is_function
template<typename> struct is_function : public false_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...)> : public true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args......)> : public true_type {};

// is_void
template<typename> struct is_void : public false_type {};
template <> struct is_void<void> : public true_type {};

// is_integral
template<typename> struct _is_integral_impl : public false_type {};
template<> struct _is_integral_impl<bool> : public true_type {};
template<> struct _is_integral_impl<char> : public true_type {};
template<> struct _is_integral_impl<signed char> : public true_type {};
template<> struct _is_integral_impl<unsigned char> : public true_type {};
template<> struct _is_integral_impl<wchar_t> : public true_type {};
template<> struct _is_integral_impl<char16_t> : public true_type {};
template<> struct _is_integral_impl<char32_t> : public true_type {};
template<> struct _is_integral_impl<short> : public true_type {};
template<> struct _is_integral_impl<unsigned short> : public true_type {};
template<> struct _is_integral_impl<int> : public true_type {};
template<> struct _is_integral_impl<unsigned int> : public true_type {};
template<> struct _is_integral_impl<long> : public true_type {};
template<> struct _is_integral_impl<unsigned long> : public true_type {};
template<> struct _is_integral_impl<long long> : public true_type {};
template<> struct _is_integral_impl<unsigned long long> : public true_type {};

template<typename T> struct is_integral : public _is_integral_impl<typename remove_cv<T>::type>::type {};

// is_floating_point
//template<typename> struct _is_floating_point_impl : public false_type {};
//template<> struct _is_floating_point_impl<float> : public true_type {};
//template<> struct _is_floating_point_impl<double> : public true_type {};
//template<> struct _is_floating_point_impl<long double> : public true_type {};
//template<typename T> struct is_floating_point : public _is_floating_point_impl<typename remove_cv<T>::type>::type {};
template <typename T> using is_floating_point = is_any_of<T, float, double, long double>;

// is_arithmetic, is_fundamental, is_object
template<typename T> using is_arithmetic = disjunction<is_integral<T>, is_floating_point<T>>;
template<typename T> using is_fundamental = disjunction<is_arithmetic<T>, is_void<T>, is_null_pointer<T>>;
template<typename T> using is_object = all_false<is_function<T>, is_reference<T>, is_void<T>>;

// is_scalar
template<typename T> using is_scalar = disjunction<is_arithmetic<T>, is_enum<T>, is_pointer<T>,
                                                   /*is_member_pointer<T>,*/ is_null_pointer<T>>;

// is_array
template<typename T> struct is_array : public false_type {};
template<typename T> struct is_array<T[]> : public true_type {};
template<typename T, size_t N> struct is_array<T[N]> : public true_type {};

// is_signed
template<typename T, bool = is_arithmetic<T>::value> struct _is_signed_impl : public false_type {};
template<typename T> struct _is_signed_impl<T, true> : public bool_constant<T(-1) < T(0)> {};
template<typename T> struct is_signed : public _is_signed_impl<T>::type {};

// is_unsigned
template<typename T> struct is_unsigned : public conjunction<is_arithmetic<T>, negation<is_signed<T>>> {};

// extent
template<typename, unsigned U>
struct extent : public integral_constant<std::size_t, 0> {};

template<typename T, unsigned U, std::size_t Size>
struct extent<T[Size], U> : public integral_constant<std::size_t, U == 0 ? Size : extent<T, U - 1>::value> {};

template<typename T, unsigned U>
struct extent<T[], U> : public integral_constant<std::size_t, U == 0 ? 0 : extent<T, U - 1>::value> {};

template<typename T>
struct _is_array_known_bounds : public bool_constant<(extent<T>::value > 0)> {};

#if __cpp_noexcept_function_type
#define LIBCXX_NOEXCEPT_PARAM , bool _NE
#define LIBCXX_NOEXCEPT_QUAL noexcept (_NE)
#else
#define LIBCXX_NOEXCEPT_PARAM
#define LIBCXX_NOEXCEPT_QUAL
#endif

template<typename T>
struct _is_referenceable : public disjunction<is_object<T>, is_reference<T>>::type {};

template<typename _Res, typename... Args LIBCXX_NOEXCEPT_PARAM>
struct _is_referenceable<_Res(Args...) LIBCXX_NOEXCEPT_QUAL> : public true_type {};

template<typename _Res, typename... Args LIBCXX_NOEXCEPT_PARAM>
struct _is_referenceable<_Res(Args......) LIBCXX_NOEXCEPT_QUAL> : public true_type {};

// is_constructible
namespace internal {
template<class, class T, class... Args> struct _is_constructible : std::false_type {};

template<class T, class... Args>
struct _is_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...> : std::true_type {};
}

template <class T, class... Args>
using is_constructible = internal::_is_constructible<void_t<>, T, Args...>;

// is_default_constructible
template<class T> struct is_default_constructible : public is_constructible<T> {};

// is_copy_constructible
template<class T> struct is_copy_constructible : public is_constructible<T, add_lvalue_reference_t<add_const_t<T>>> {};

// is_move_constructible
template <typename T> struct is_move_constructible : public is_constructible<T,add_rvalue_reference_t<T>> {};

template<typename T> struct _is_nt_def_ctorible_impl2 : public bool_constant<noexcept(T())> {};
template<typename T, bool = is_array<T>::value> struct _is_nt_def_ctorible_impl;

template<typename T>
struct _is_nt_def_ctorible_impl<T, true> : public conjunction<_is_array_known_bounds<T>,
        _is_nt_def_ctorible_impl2<typename remove_all_extents<T>::type>> {};

template<typename T>
struct _is_nt_def_ctorible_impl<T, false> : public _is_nt_def_ctorible_impl2<T> {};

// is_nothrow_default_constructible
template<typename T>
struct is_nothrow_default_constructible : public conjunction<is_default_constructible<T>, _is_nt_def_ctorible_impl<T>> {};

// is_nothrow_constructible
template<typename T, typename... Args>
struct _is_nt_ctorible_impl : public bool_constant<noexcept(T(declval<Args>()...))> {};

template<typename T, typename Arg>
struct _is_nt_ctorible_impl<T, Arg> : public bool_constant<noexcept(static_cast<T>(declval<Arg>()))> {};

template<typename T> struct _is_nt_ctorible_impl<T> : public is_nothrow_default_constructible<T> {};

template<typename T, typename...Args>
struct is_nothrow_constructible : public conjunction<is_constructible<T, Args...>, _is_nt_ctorible_impl<T, Args...>> {};

// is_nothrow_move_constructible
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_move_ctorible_impl;
template<typename T> struct _is_nt_move_ctorible_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_move_ctorible_impl<T, true> : public is_nothrow_constructible<T, T&&> {};
template<typename T> struct is_nothrow_move_constructible : public _is_nt_move_ctorible_impl<T> {};

// is_nothrow_copy_constructible
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_copy_ctorible_impl;
template<typename T> struct _is_nt_copy_ctorible_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_copy_ctorible_impl<T, true> : public is_nothrow_constructible<T, T const&> {};
template<typename T> struct is_nothrow_copy_constructible : public _is_nt_copy_ctorible_impl<T> {};

// is_destructible
template <typename T> using __detect_dtor = decltype(declval<T&>().~T());
template <typename T>
using is_destructible = conjunction<all_false<is_function<T>, is_array<T>, is_void<T>>,
                                    disjunction<is_reference<T>, is_detected<__detect_dtor, remove_all_extents_t<T>>>>;

// is_trivially_destructible
template<typename T> struct is_trivially_destructible : public bool_constant<__has_trivial_destructor(T)> {};
template<> struct is_trivially_destructible<void> : public true_type {};

template<typename T>
struct __is_array_known_bounds : public integral_constant<bool, (extent<T>::value > 0)> {};

template<typename T>
struct __is_array_unknown_bounds : public conjunction<is_array<T>, negation<extent<T>>> {};

struct __do_is_nt_destructible_impl
{
    template<typename T> static bool_constant<noexcept(declval<T&>().~T())> __test(int);
    template<typename> static false_type __test(...);
};

template<typename T>
struct __is_nt_destructible_impl
        : public __do_is_nt_destructible_impl
{
    typedef decltype(__test<T>(0)) type;
};

template<typename T, bool = disjunction<is_void<T>, __is_array_unknown_bounds<T>, is_function<T>>::value,
                     bool = disjunction<is_reference<T>, is_scalar<T>>::value>
struct __is_nt_destructible_safe;

template<typename T>
struct __is_nt_destructible_safe<T, false, false> : public __is_nt_destructible_impl<remove_all_extents<T>>::type
{};

template<typename T> struct __is_nt_destructible_safe<T, true, false> : public false_type {};

template<typename T> struct __is_nt_destructible_safe<T, false, true> : public true_type {};

/// is_nothrow_destructible
template<typename T> struct is_nothrow_destructible : public __is_nt_destructible_safe<T>::type {};

// is_assignable
template<typename T, typename U>
struct is_assignable : public bool_constant<__is_assignable(T, U)> {};

// is_copy_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_copy_assignable_impl;
template<typename T> struct _is_copy_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_copy_assignable_impl<T, true> : public is_assignable<T&, const T&> {};
template<typename T> struct is_copy_assignable : public _is_copy_assignable_impl<T> {};

// is_move_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_move_assignable_impl;
template<typename T> struct _is_move_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_move_assignable_impl<T, true> : public is_assignable<T&, T&&> {};
template<typename T> struct is_move_assignable : public _is_move_assignable_impl<T> {};

// is_nothrow_assignable
template<typename T, typename U>
struct _is_nt_assignable_impl : public bool_constant<noexcept(declval<T>() = declval<U>())> {};
template<typename T, typename U>
struct is_nothrow_assignable : public conjunction<is_assignable<T, U>, _is_nt_assignable_impl<T, U>> {};

// is_nothrow_copy_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_copy_assignable_impl;
template<typename T> struct _is_nt_copy_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_copy_assignable_impl<T, true> : public is_nothrow_assignable<T&, const T&> {};
template<typename T> struct is_nothrow_copy_assignable : public _is_nt_copy_assignable_impl<T> {};

// is_nothrow_move_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_move_assignable_impl;
template<typename T> struct _is_nt_move_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_move_assignable_impl<T, true> : public is_nothrow_assignable<T&, T&&> {};
template<typename T> struct is_nothrow_move_assignable : public _is_nt_move_assignable_impl<T> {};

// is_base_of
template <typename Base, typename Derived>
struct is_base_of : public bool_constant<__is_base_of(Base, Derived)> {};

// is_convertible
template <typename From, typename To, bool = disjunction<is_void<From>, is_function<To>, is_array<To>>::value>
struct _is_convertible_helper { using type = typename is_void<To>::type; };

template <typename From, typename To>
class _is_convertible_helper<From, To, false>
{
    template<typename T> static void test_(T);
    template<typename F, typename T, typename = decltype(test_<T>(std::declval<F>()))> static true_type test(int);
    template<typename, typename> static false_type test(...);
  public:
    using type = decltype(test<From, To>(0));
};

template <typename From, typename To> struct is_convertible : public _is_convertible_helper<From, To>::type {};

template<typename T> struct is_nothrow_swappable;

template<typename T>
constexpr void swap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&
                                         is_nothrow_move_assignable<T>::value);

template<class T2, std::size_t N>
constexpr void swap(T2 (&a)[N], T2 (&b)[N]) noexcept(is_nothrow_swappable<T2>::value);

namespace __swap {
using std::swap;

template <typename From, typename To> using __detect_adl_swap = decltype(swap(declval<remove_reference_t<From>&>(), declval<remove_reference_t<To>&>()));
}

template <typename From, typename To = From>
using __is_swappable_impl = conjunction<is_detected<__swap::__detect_adl_swap, From, To>,
                                        is_detected<__swap::__detect_adl_swap, To, From>>;

template <typename From, typename To = From>
class _is_nothrow_swappable_impl
{
    template<typename U, typename V> static bool_constant<noexcept(swap(declval<U&>(), declval<V&>()))> _test(int);
    template<typename, typename> static false_type _test(...);
  public:
    using type = decltype(_test<From, To>(0));
};

// is_swappable
template <typename T> struct is_swappable : public __is_swappable_impl<T> {};
template <typename T,typename U> struct is_swappable_with : public __is_swappable_impl<T, U> {};

// is_nothrow_swappable
template<typename T> struct is_nothrow_swappable : public _is_nothrow_swappable_impl<T>::type {};
template <typename T,typename U> struct is_nothrow_swappable_with : public _is_nothrow_swappable_impl<T, U>::type {};

// ====================================================
// Related types
// ====================================================

// common_type
template <typename...Ts> struct common_type {};

template <typename T> using __member_type_t = typename T::type;
template<typename T1, typename T2> using __cond_t = decltype(false ? declval<T1>() : declval<T2>());

template <typename T, typename U> using __common_type_impl = identity<decay_t<detected_t<__cond_t, T, U>>>;
template<typename T, typename U, typename... Rest>
using __multi_common_type_impl = conditional_t<is_detected_v<__member_type_t, common_type<T, U>>,
                                               common_type<common_type<T, U>, Rest...>, nonesuch>;

template <typename T> struct common_type<T> : common_type<T, T> {};
template <typename T1, typename T2> struct common_type<T1, T2> : __common_type_impl<decay_t<T1>, decay_t<T2>> {};

template<typename T, typename U, typename... Rest>
struct common_type<T, U, Rest...> : public __multi_common_type_impl<T, U, Rest...>::type {};

template<typename... Ts> using common_type_t = typename common_type<Ts...>::type;

template<typename, typename, typename = void> struct __common_type_fold;
template<typename CT, typename... R>
struct __common_type_fold<CT, __pack_t<R...>, void_t<typename CT::type>> : common_type<typename CT::type, R...> {};
template<typename CT, typename R> struct __common_type_fold<CT, R, void> {};

template<typename A, typename B, typename = void> struct __common_ref_impl {};

template<typename From, typename To>
using __copy_cv_t = apply_cv_t<To, is_const<From>::value, is_volatile<From>::value>;

template<typename... _Cond> using __require = enable_if_t<conjunction<_Cond...>::value>;

template<typename T> struct __xref { template<typename U> using type = __copy_cv_t<T, U>; };
template<typename T> struct __xref<T&> { template<typename U> using type = __copy_cv_t<T, U>&; };
template<typename T> struct __xref<T&&> { template<typename U> using type = __copy_cv_t<T, U>&&; };

template<typename T1, typename T2>
using __cond_res = decltype(false ? declval<T1(&)()>()() : declval<T2(&)()>()());

template<typename A, typename B>
using __common_ref = typename __common_ref_impl<A, B>::type;

template<typename X, typename Y>
struct __common_ref_impl<X&, Y&, void_t<__cond_res<__copy_cv_t<X, Y>&, __copy_cv_t<Y, X>&>>>
        : identity<__cond_res<__copy_cv_t<X, Y>&, __copy_cv_t<Y, X>&>> {};

template<typename X, typename Y>
using __common_ref_C = remove_reference_t<__common_ref<X&, Y&>>&&;
template<typename X, typename Y>
struct __common_ref_impl<X&&, Y&&,
        __require<is_convertible<X&&, __common_ref_C<X, Y>>, is_convertible<Y&&, __common_ref_C<X, Y>>>> : identity<__common_ref_C<X, Y>> {};
template<typename X, typename Y>
using __common_ref_D = __common_ref<const X&, Y&>;
template<typename X, typename Y>
struct __common_ref_impl<X&&, Y&, __require<is_convertible<X&&, __common_ref_D<X, Y>>>> : identity<__common_ref_D<X, Y>> {};
template<typename X, typename Y> struct __common_ref_impl<X&, Y&&> : __common_ref_impl<Y&&, X&> {};

template<typename T, typename U, template<typename> class TQual, template<typename> class UQual>
struct basic_common_reference {};
template<typename T, typename U, template<typename> class TQual, template<typename> class UQual>
using __basic_common_reference_t = typename basic_common_reference<T, U, TQual, UQual>::type;
template<typename T1, typename T2>
using __basic_common_ref = __basic_common_reference_t<remove_cvref_t<T1>, remove_cvref_t<T2>,
                                                      __xref<T1>::template type, __xref<T2>::template type>;

template<typename... T> struct common_reference;

template<> struct common_reference<> {};
template<typename T> struct common_reference<T> : identity<T> {};
template<typename... Ts> using common_reference_t = typename common_reference<Ts...>::type;

template<typename T1, typename T2, int _Bullet = 1, typename = void>
struct __common_reference_impl : __common_reference_impl<T1, T2, _Bullet + 1> {};
template<typename T1, typename T2>
struct common_reference<T1, T2> : __common_reference_impl<T1, T2> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1&, T2&, 1, void_t<__common_ref<T1&, T2&>>> : identity<__common_ref<T1&, T2&>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1&&, T2&&, 1, void_t<__common_ref<T1&&, T2&&>>> : identity<__common_ref<T1&&, T2&&>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1&, T2&&, 1, void_t<__common_ref<T1&, T2&&>>> : identity<__common_ref<T1&, T2&&>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1&&, T2&, 1, void_t<__common_ref<T1&&, T2&>>> : identity<__common_ref<T1&&, T2&>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1, T2, 2, void_t<__basic_common_ref<T1, T2>>> : identity<__basic_common_ref<T1, T2>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1, T2, 3, void_t<__cond_res<T1, T2>>> : identity<__cond_res<T1, T2>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1, T2, 4, void_t<common_type_t<T1, T2>>> : identity<common_type_t<T1, T2>> {};
template<typename T1, typename T2>
struct __common_reference_impl<T1, T2, 5, void> {};

template<typename T1, typename T2, typename... _Rest>
struct common_reference<T1, T2, _Rest...> : __common_type_fold<common_reference<T1, T2>, __pack_t<_Rest...>> {};

template<typename T1, typename T2, typename... _Rest>
struct __common_type_fold<common_reference<T1, T2>, __pack_t<_Rest...>, void_t<common_reference_t<T1, T2>>>
        : public common_reference<common_reference_t<T1, T2>, _Rest...> {};

// underlying_type
template <typename T> using underlying_type = conditional_t<is_enum<T>::value, identity<__underlying_type(T)>, nonesuch>;

// ====================================================
// Type properties (bool values)
// ====================================================
template <typename T1, typename T2> constexpr inline bool is_same_v = is_same<T1, T2>::value;
template <typename Base, typename Derived> constexpr inline bool is_base_of_v = is_base_of<Base, Derived>::value;
template <typename From, typename To> constexpr inline bool is_convertible_v = is_convertible<From, To>::value;

// See C++14 20.10.4.1, primary type categories
template <class T> inline constexpr bool is_void_v = is_void<T>::value;
template <class T> inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
template <class T> inline constexpr bool is_integral_v = is_integral<T>::value;
template <class T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;
template <class T> inline constexpr bool is_array_v = is_array<T>::value;
template <class T> inline constexpr bool is_pointer_v = is_pointer<T>::value;
template <class T> inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
template <class T> inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;
//template <class T> inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;
//template <class T> inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;
template <class T> inline constexpr bool is_enum_v = is_enum<T>::value;
template <class T> inline constexpr bool is_union_v = is_union<T>::value;
template <class T> inline constexpr bool is_class_v = is_class<T>::value;
template <class T> inline constexpr bool is_function_v = is_function<T>::value;

// See C++14 20.10.4.2, composite type categories
template <class T> inline constexpr bool is_reference_v = is_reference<T>::value;
template <class T> inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
template <class T> inline constexpr bool is_fundamental_v = is_fundamental<T>::value;
template <class T> inline constexpr bool is_object_v = is_object<T>::value;
template <class T> inline constexpr bool is_scalar_v = is_scalar<T>::value;
//template <class T> inline constexpr bool is_compound_v = is_compound<T>::value;
//template <class T> inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;
// See C++14 20.10.4.3, type properties
template <class T> inline constexpr bool is_const_v = is_const<T>::value;
template <class T> inline constexpr bool is_volatile_v = is_volatile<T>::value;
//template <class T> inline constexpr bool is_trivial_v = is_trivial<T>::value;
//template <class T> inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;
//template <class T> inline constexpr bool is_standard_layout_v = is_standard_layout<T>::value;
//template <class T> inline constexpr bool is_pod_v = is_pod<T>::value;
//template <class T> inline constexpr bool is_literal_type_v = is_literal_type<T>::value;
//template <class T> inline constexpr bool is_empty_v = is_empty<T>::value;
//template <class T> inline constexpr bool is_polymorphic_v = is_polymorphic<T>::value;
//template <class T> inline constexpr bool is_abstract_v = is_abstract<T>::value;
//template <class T> inline constexpr bool is_final_v = is_final<T>::value;
//template <class T> inline constexpr bool is_aggregate_v = is_aggregate<T>::value;
template <class T> inline constexpr bool is_signed_v = is_signed<T>::value;
template <class T> inline constexpr bool is_unsigned_v = is_unsigned<T>::value;

template <class T, class... Args> inline constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
template <class T> inline constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
template <class T> inline constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;
template <class T> inline constexpr bool is_move_constructible_v = is_move_constructible<T>::value;
template <class T, class U> inline constexpr bool is_assignable_v = is_assignable<T, U>::value;
template <class T> inline constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;
template <class T> inline constexpr bool is_move_assignable_v = is_move_assignable<T>::value;
template <class T, class U> inline constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
template <class T> inline constexpr bool is_swappable_v = is_swappable<T>::value;
template <class T> inline constexpr bool is_destructible_v = is_destructible<T>::value;
//template <class T, class... Args> inline constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;
//template <class T> inline constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<T>::value;
//template <class T> inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<T>::value;
//template <class T> inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<T>::value;
//template <class T, class U> inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;
//template <class T> inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<T>::value;
//template <class T> inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;
template <class T> inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;
template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;
template <class T> inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<T>::value;
template <class T> inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<T>::value;
template <class T> inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<T>::value;
template <class T, class U> inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<T, U>::value;
template <class T> inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<T>::value;
template <class T> inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;
template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<T, U>::value;
template <class T> inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;
template <class T> inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;
//template <class T> inline constexpr bool has_virtual_destructor_v = has_virtual_destructor<T>::value;

} // namespace std
