#pragma once

namespace std {

namespace internal {

template <typename...> struct _or;
template <typename> struct _not;

}

// ====================================================
// Type transformations
// ====================================================

// remove_reference
template <typename T> struct remove_reference      { using type = T; };
template <typename T> struct remove_reference<T&>  { using type = T; };
template <typename T> struct remove_reference<T&&> { using type = T; };
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

// add_lvalue_Reference
template <typename T> struct add_lvalue_reference { using type = T&; };
template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

// add_rvalue_reference
template <typename T> struct add_rvalue_reference { using type = T&&; };
template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

// add_const
template <typename T> struct add_const { using type = T const; };
template <typename T> using add_const_t = typename add_const<T>::type;

// ====================================================
// Type traits
// ====================================================

template<typename T> typename add_rvalue_reference<T>::type declval() noexcept;

template<typename T, T _value>
struct integral_constant
{
    using type = integral_constant;
    using value_type = T;

    static constexpr T value = _value;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template<typename T, T _value>
constexpr T integral_constant<T, _value>::value;

using true_type = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

// is_lvalue_reference
template<typename> struct is_lvalue_reference : public false_type {};
template<typename T> struct is_lvalue_reference<T&> : public true_type {};

// is_rvalue_reference
template<typename> struct is_rvalue_reference : public false_type {};
template<typename T> struct is_rvalue_reference<T&&> : public true_type {};

template<typename T>
struct is_reference : public internal::_or<is_lvalue_reference<T>,
                                           is_rvalue_reference<T>>::type
{ };

// is_function
template<typename> struct is_function : public false_type {};

// is_void
template<typename> struct is_void : public false_type {};
template <> struct is_void<void> : public true_type {};

// is_object
template<typename _Tp>
struct is_object : public internal::_not<internal::_or<is_function<_Tp>,
                                                       is_reference<_Tp>,
                                                       is_void<_Tp>>>::type {};

template <class...>
using void_t = void;

// is_constructible
template <class, class T, class... Args>
struct __is_constructible : std::false_type {};

template <class T, class... Args>
struct __is_constructible<
        void_t<decltype(T(std::declval<Args>()...))>,
        T, Args...> : std::true_type {};

template <class T, class... Args>
using is_constructible = __is_constructible<void_t<>, T, Args...>;

// is_copy_constructible
template<class T>
struct is_copy_constructible : public is_constructible<T,
        typename add_lvalue_reference<typename add_const<T>::type>::type> {};

// conditional
template<bool Pred, typename Then, typename Else>
struct conditional { using type = Then; };

template<typename Then, typename Else>
struct conditional<false, Then, Else> { using type = Else; };

// enable_if
template <bool, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

namespace internal {

// OR conditional
template <> struct _or<> : public std::false_type {};
template <typename T1> struct _or<T1> : public T1 {};

template <typename T1, typename T2>
struct _or<T1, T2> : public conditional<T1::value, T1, T2>::type {};

template<typename T1, typename T2, typename T3, typename... Tn>
struct _or<T1, T2, T3, Tn...>
        : public conditional<T1::value, T1, _or<T2, T3, Tn...>>::type {};

// NOT conditional
template<typename T>
struct _not : public integral_constant<bool, !bool(T::value)> {};

} // namespace internal

} // namespace std
