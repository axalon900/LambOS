#pragma once

#include <stddef.h>

namespace std {

namespace internal {

template <typename...> struct _or;
template <typename> struct _not;

}

// ====================================================
// Forward declarations
// ====================================================

template<typename T> struct is_array;
template<typename T> struct is_function;

// ====================================================
// SFINAE and conditionals
// ====================================================

// conditional
template<bool Pred, typename Then, typename Else>
struct conditional { using type = Then; };

template<typename Then, typename Else>
struct conditional<false, Then, Else> { using type = Else; };

template <bool Pred, typename Then, typename Else>
using conditional_t = typename conditional<Pred, Then, Else>::type;

// enable_if
template <bool, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

// ====================================================
// Type transformations
// ====================================================

// remove_extent
template<typename T> struct remove_extent { using type = T; };
template<typename T> struct remove_extent<T[]> { using type = T; };
template<typename T, size_t N> struct remove_extent<T[N]> { using type = T; };
template<typename T> using remove_extent_t = typename remove_extent<T>::type;

// remove_reference
template <typename T> struct remove_reference      { using type = T; };
template <typename T> struct remove_reference<T&>  { using type = T; };
template <typename T> struct remove_reference<T&&> { using type = T; };
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

// remove_volatile
template<typename T> struct remove_volatile { using type = T; };
template<typename T> struct remove_volatile<volatile T> { using type = T; };
template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;

// remove_const
template<typename T> struct remove_const { using type = T; };
template<typename T> struct remove_const<const T> { using type = T; };
template<typename T> using remove_const_t = typename remove_const<T>::type;

// remove_cv
template<typename T>
struct remove_cv {
    using type = std::remove_volatile_t<typename std::remove_const_t<T>>;
};
template<typename T> using remove_cv_t = typename remove_cv<T>::type;

// add_lvalue_Reference
template <typename T> struct add_lvalue_reference { using type = T&; };
template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

// add_rvalue_reference
template <typename T> struct add_rvalue_reference { using type = T&&; };
template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

// add_const
template <typename T> struct add_const { using type = T const; };
template <typename T> using add_const_t = typename add_const<T>::type;

// add_pointer
template<typename T>
struct add_pointer { using type = typename std::remove_reference_t<T>*; };
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

template<typename T>
struct decay {
  private:
    using U = remove_reference_t<T>;
  public:
    using type = conditional_t<is_array<U>::value,
                               remove_extent_t<U>*,
                               conditional_t<
                                       is_function<U>::value,
                                       add_pointer_t<U>,
                                       remove_cv_t<U>>>;
};

// ====================================================
// Type traits
// ====================================================

template<typename T> typename add_rvalue_reference<T>::type declval() noexcept;

template<typename T, T _value>
struct integral_constant
{
    using type = integral_constant;
    using value_type = T;

    static constexpr T value = _value;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template<typename T, T _value>
constexpr T integral_constant<T, _value>::value;

using true_type = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

// is_lvalue_reference
template<typename> struct is_lvalue_reference : public false_type {};
template<typename T> struct is_lvalue_reference<T&> : public true_type {};

// is_rvalue_reference
template<typename> struct is_rvalue_reference : public false_type {};
template<typename T> struct is_rvalue_reference<T&&> : public true_type {};

template<typename T>
struct is_reference : public internal::_or<is_lvalue_reference<T>,
                                           is_rvalue_reference<T>>::type
{ };

// is_function
template<typename> struct is_function : public false_type {};
template<typename Ret, typename... Args>
struct is_function<Ret(Args...)> : public true_type {};
template<typename Ret, typename... Args>
struct is_function<Ret(Args......)> : public true_type {};

// is_void
template<typename> struct is_void : public false_type {};
template <> struct is_void<void> : public true_type {};

// is_object
template<typename _Tp>
struct is_object : public internal::_not<internal::_or<is_function<_Tp>,
                                                       is_reference<_Tp>,
                                                       is_void<_Tp>>>::type {};

// is_array
template<typename T> struct is_array : public false_type {};
template<typename T> struct is_array<T[]> : public true_type {};
template<typename T, size_t N> struct is_array<T[N]> : public true_type {};

template <class...>
using void_t = void;

// is_constructible
template <class, class T, class... Args>
struct __is_constructible : std::false_type {};

template <class T, class... Args>
struct __is_constructible<
        void_t<decltype(T(std::declval<Args>()...))>,
        T, Args...> : std::true_type {};

template <class T, class... Args>
using is_constructible = __is_constructible<void_t<>, T, Args...>;

// is_default_constructible
template<class T> struct is_default_constructible
        : public is_constructible<T> {};

// is_copy_constructible
template<class T> struct is_copy_constructible
        : public is_constructible<T, add_lvalue_reference_t<add_const_t<T>>> {};

// is_move_constructible
template <typename T> struct is_move_constructible
        : public is_constructible<T,add_rvalue_reference_t<T>> {};

template<typename T> struct is_trivially_destructible
        : public integral_constant<bool, __has_trivial_destructor(T)> {};
template<> struct is_trivially_destructible<void> : public true_type {};

// is_same
template <typename, typename> struct is_same : public false_type {};
template <typename T> struct is_same<T, T> : public true_type {};

// ====================================================
// Internal helpers
// ====================================================

namespace internal {

// OR conditional
template <> struct _or<> : public std::false_type {};
template <typename T1> struct _or<T1> : public T1 {};

template <typename T1, typename T2>
struct _or<T1, T2> : public conditional<T1::value, T1, T2>::type {};

template<typename T1, typename T2, typename T3, typename... Tn>
struct _or<T1, T2, T3, Tn...>
        : public conditional<T1::value, T1, _or<T2, T3, Tn...>>::type {};

// NOT conditional
template<typename T>
struct _not : public integral_constant<bool, !bool(T::value)> {};

} // namespace internal

} // namespace std
