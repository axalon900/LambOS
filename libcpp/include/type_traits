#pragma once

#include <stddef.h>

namespace std {

// ====================================================
// Forward declarations
// ====================================================

template<typename T> struct is_array;
template<typename T> struct is_function;

// ====================================================
// SFINAE and conditionals
// ====================================================

template<typename T, T _value>
struct integral_constant
{
    using type = integral_constant;
    using value_type = T;

    static constexpr T value = _value;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template<typename T, T _value>
constexpr T integral_constant<T, _value>::value;

using true_type = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

template <bool Value> using bool_constant = std::integral_constant<bool, Value>;

// conditional
template<bool Pred, typename Then, typename Else>
struct conditional { using type = Then; };

template<typename Then, typename Else>
struct conditional<false, Then, Else> { using type = Else; };

template <bool Pred, typename Then, typename Else>
using conditional_t = typename conditional<Pred, Then, Else>::type;

template<class...> struct conjunction : std::true_type {};
template<class B1> struct conjunction<B1> : B1 {};
template<class B1, class... Bn> struct conjunction<B1, Bn...> : conditional_t<bool(B1::value), conjunction<Bn...>, B1> {};

template<class...> struct disjunction : std::false_type {};
template<class B1> struct disjunction<B1> : B1 {};
template<class B1, class... Bn> struct disjunction<B1, Bn...> : conditional_t<bool(B1::value), B1, disjunction<Bn...>> {};

template<class B> struct negation : bool_constant<!bool(B::value)> {};

// enable_if
template <bool, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

// ====================================================
// Type transformations
// ====================================================

// remove_extent
template<typename T> struct remove_extent { using type = T; };
template<typename T> struct remove_extent<T[]> { using type = T; };
template<typename T, size_t N> struct remove_extent<T[N]> { using type = T; };
template<typename T> using remove_extent_t = typename remove_extent<T>::type;

// remove_reference
template <typename T> struct remove_reference      { using type = T; };
template <typename T> struct remove_reference<T&>  { using type = T; };
template <typename T> struct remove_reference<T&&> { using type = T; };
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

// remove_volatile
template<typename T> struct remove_volatile { using type = T; };
template<typename T> struct remove_volatile<volatile T> { using type = T; };
template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;

// remove_const
template<typename T> struct remove_const { using type = T; };
template<typename T> struct remove_const<const T> { using type = T; };
template<typename T> using remove_const_t = typename remove_const<T>::type;

// remove_pointer
template<typename T> struct remove_pointer { using type = T; };
template<typename T> struct remove_pointer<T*> { using type = T; };
template<typename T> using remove_pointer_t = typename remove_pointer<T>::type;

// remove_cv
template<typename T>
struct remove_cv {
    using type = std::remove_volatile_t<typename std::remove_const_t<T>>;
};
template<typename T> using remove_cv_t = typename remove_cv<T>::type;

// add_lvalue_Reference
template <typename T> struct add_lvalue_reference { using type = T&; };
template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

// add_rvalue_reference
template <typename T> struct add_rvalue_reference { using type = T&&; };
template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

// add_const
template <typename T> struct add_const { using type = T const; };
template <typename T> using add_const_t = typename add_const<T>::type;

// add_pointer
template<typename T>
struct add_pointer { using type = typename std::remove_reference_t<T>*; };
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

template<typename T>
struct decay {
  private:
    using U = remove_reference_t<T>;
  public:
    using type = conditional_t<is_array<U>::value,
                               remove_extent_t<U>*,
                               conditional_t<
                                       is_function<U>::value,
                                       add_pointer_t<U>,
                                       remove_cv_t<U>>>;
};
template <typename T> using decay_t = typename std::decay<T>::type;

// ====================================================
// Type traits
// ====================================================

template<typename T> typename add_rvalue_reference<T>::type declval() noexcept;

// is_const
template<typename> struct is_const : public false_type {};
template<typename T> struct is_const<const T> : public true_type {};

// is_lvalue_reference
template<typename> struct is_lvalue_reference : public false_type {};
template<typename T> struct is_lvalue_reference<T&> : public true_type {};

// is_rvalue_reference
template<typename> struct is_rvalue_reference : public false_type {};
template<typename T> struct is_rvalue_reference<T&&> : public true_type {};

template<typename T>
struct is_reference : public disjunction<is_lvalue_reference<T>,
                                         is_rvalue_reference<T>>::type {};

// is_null_pointer

template<typename> struct _is_null_pointer_impl : public false_type {};

template<> struct _is_null_pointer_impl<decltype(nullptr)> : public true_type {};

template<typename T>
struct is_null_pointer : public _is_null_pointer_impl<typename remove_cv<T>::type>::type {};

// is_function
template<typename> struct is_function : public false_type {};
template<typename Ret, typename... Args>
struct is_function<Ret(Args...)> : public true_type {};
template<typename Ret, typename... Args>
struct is_function<Ret(Args......)> : public true_type {};

// is_void
template<typename> struct is_void : public false_type {};
template <> struct is_void<void> : public true_type {};

// is_integral
template<typename> struct _is_integral_impl : public false_type {};
template<> struct _is_integral_impl<bool> : public true_type {};
template<> struct _is_integral_impl<char> : public true_type {};
template<> struct _is_integral_impl<signed char> : public true_type {};
template<> struct _is_integral_impl<unsigned char> : public true_type {};
template<> struct _is_integral_impl<wchar_t> : public true_type {};
template<> struct _is_integral_impl<char16_t> : public true_type {};
template<> struct _is_integral_impl<char32_t> : public true_type {};
template<> struct _is_integral_impl<short> : public true_type {};
template<> struct _is_integral_impl<unsigned short> : public true_type {};
template<> struct _is_integral_impl<int> : public true_type {};
template<> struct _is_integral_impl<unsigned int> : public true_type {};
template<> struct _is_integral_impl<long> : public true_type {};
template<> struct _is_integral_impl<unsigned long> : public true_type {};
template<> struct _is_integral_impl<long long> : public true_type {};
template<> struct _is_integral_impl<unsigned long long> : public true_type {};

template<typename T> struct is_integral : public _is_integral_impl<typename remove_cv<T>::type>::type {};

// is_floating_point
template<typename> struct _is_floating_point_impl : public false_type { };
template<> struct _is_floating_point_impl<float> : public true_type {};
template<> struct _is_floating_point_impl<double> : public true_type {};
template<> struct _is_floating_point_impl<long double> : public true_type {};

template<typename T>
struct is_floating_point : public _is_floating_point_impl<typename remove_cv<T>::type>::type {};

/// is_arithmetic
template<typename T>
struct is_arithmetic : public disjunction<is_integral<T>, is_floating_point<T>>::type {};

/// is_fundamental
template<typename T>
struct is_fundamental
        : public disjunction<is_arithmetic<T>, is_void<T>,
                is_null_pointer<T>>::type
{};

// is_object
template<typename T>
struct is_object : public negation<disjunction<is_function<T>,
                                               is_reference<T>,
                                               is_void<T>>>::type {};

// is_array
template<typename T> struct is_array : public false_type {};
template<typename T> struct is_array<T[]> : public true_type {};
template<typename T, size_t N> struct is_array<T[N]> : public true_type {};

// is_signed
template<typename T, bool = is_arithmetic<T>::value> struct _is_signed_impl : public false_type {};
template<typename T> struct _is_signed_impl<T, true> : public integral_constant<bool, T(-1) < T(0)> {};
template<typename T> struct is_signed : public _is_signed_impl<T>::type {};

// is_unsigned
template<typename T> struct is_unsigned : public conjunction<is_arithmetic<T>, negation<is_signed<T>>> {};

template <class...>
using void_t = void;

// is_constructible
namespace internal {
template<class, class T, class... Args> struct _is_constructible : std::false_type {};

template<class T, class... Args>
struct _is_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...> : std::true_type {};
}

template <class T, class... Args>
using is_constructible = internal::_is_constructible<void_t<>, T, Args...>;

// is_default_constructible
template<class T> struct is_default_constructible
        : public is_constructible<T> {};

// is_copy_constructible
template<class T> struct is_copy_constructible
        : public is_constructible<T, add_lvalue_reference_t<add_const_t<T>>> {};

// is_move_constructible
template <typename T> struct is_move_constructible
        : public is_constructible<T,add_rvalue_reference_t<T>> {};

template<typename T> struct is_trivially_destructible
        : public integral_constant<bool, __has_trivial_destructor(T)> {};
template<> struct is_trivially_destructible<void> : public true_type {};

// is_same
template <typename, typename> struct is_same : public false_type {};
template <typename T> struct is_same<T, T> : public true_type {};

} // namespace std
