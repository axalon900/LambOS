#pragma once

#include <cstddef>

namespace std {

// ====================================================
// Forward declarations
// ====================================================

template<typename, unsigned = 0> struct extent;
template<typename T> struct is_array;
template<typename T> struct is_function;

// ====================================================
// SFINAE and conditionals
// ====================================================

template<typename T, T _value>
struct integral_constant
{
    using type = integral_constant;
    using value_type = T;

    static constexpr T value = _value;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template<typename T, T _value>
constexpr T integral_constant<T, _value>::value;
template <bool Value> using bool_constant = std::integral_constant<bool, Value>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

template <typename T>
struct identity { using type = T; };

// conditional

//template<bool Pred, typename Then, typename Else>
//struct conditional { using type = Then; };
//
//template<typename Then, typename Else>
//struct conditional<false, Then, Else> { using type = Else; };

// compiles way faster/generates less symbols than above
template <bool Cond> struct _conditional_impl { template <typename Then, typename Else> using type = identity<Then>; };
template <> struct _conditional_impl<false> { template <typename Then, typename Else> using type = identity<Else>; };

template <bool Cond, typename Then, typename Else>
using conditional = typename _conditional_impl<Cond>::template type<Then, Else>;

template <bool Cond, typename Then, typename Else>
using conditional_t = typename conditional<Cond, Then, Else>::type;


template<class...> struct conjunction : std::true_type {};
template<class B1> struct conjunction<B1> : B1 {};
template<class B1, class... Bn> struct conjunction<B1, Bn...> : conditional_t<bool(B1::value), conjunction<Bn...>, B1> {};

template<class...> struct disjunction : std::false_type {};
template<class B1> struct disjunction<B1> : B1 {};
template<class B1, class... Bn> struct disjunction<B1, Bn...> : conditional_t<bool(B1::value), B1, disjunction<Bn...>> {};

template<class B> struct negation : bool_constant<!bool(B::value)> {};

// enable_if
template <bool, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

// ====================================================
// Type transformations
// ====================================================

// remove_extent
template<typename T> struct remove_extent { using type = T; };
template<typename T> struct remove_extent<T[]> { using type = T; };
template<typename T, size_t N> struct remove_extent<T[N]> { using type = T; };
template<typename T> using remove_extent_t = typename remove_extent<T>::type;

// remove_reference
template <typename T> struct remove_reference      { using type = T; };
template <typename T> struct remove_reference<T&>  { using type = T; };
template <typename T> struct remove_reference<T&&> { using type = T; };
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

// remove_volatile
template<typename T> struct remove_volatile { using type = T; };
template<typename T> struct remove_volatile<volatile T> { using type = T; };
template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;

// remove_const
template<typename T> struct remove_const { using type = T; };
template<typename T> struct remove_const<const T> { using type = T; };
template<typename T> using remove_const_t = typename remove_const<T>::type;

// remove_pointer
template<typename T> struct remove_pointer { using type = T; };
template<typename T> struct remove_pointer<T*> { using type = T; };
template<typename T> using remove_pointer_t = typename remove_pointer<T>::type;

// remove_cv
template<typename T>
struct remove_cv {
    using type = std::remove_volatile_t<typename std::remove_const_t<T>>;
};
template<typename T> using remove_cv_t = typename remove_cv<T>::type;

// remove_all_extents
template<typename T> struct remove_all_extents { using type = T; };
template<typename T, std::size_t Size> struct remove_all_extents<T[Size]> { using type = typename remove_all_extents<T>::type; };
template<typename T> struct remove_all_extents<T[]> { using type = typename remove_all_extents<T>::type; };

// add_lvalue_Reference
template <typename T> struct add_lvalue_reference { using type = T&; };
template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

// add_rvalue_reference
template <typename T> struct add_rvalue_reference { using type = T&&; };
template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

// add_const
template <typename T> struct add_const { using type = T const; };
template <typename T> using add_const_t = typename add_const<T>::type;

// add_pointer
template<typename T>
struct add_pointer { using type = typename std::remove_reference_t<T>*; };
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

template<typename T>
struct decay {
  private:
    using U = remove_reference_t<T>;
  public:
    using type = conditional_t<is_array<U>::value, remove_extent_t<U>*,
                               conditional_t<is_function<U>::value, add_pointer_t<U>, remove_cv_t<U>>>;
};
template <typename T> using decay_t = typename std::decay<T>::type;

// ====================================================
// Type traits
// ====================================================

template<typename T> typename add_rvalue_reference<T>::type declval() noexcept;

// is_const
template<typename> struct is_const : public false_type {};
template<typename T> struct is_const<const T> : public true_type {};

// is_lvalue_reference
template<typename> struct is_lvalue_reference : public false_type {};
template<typename T> struct is_lvalue_reference<T&> : public true_type {};

// is_rvalue_reference
template<typename> struct is_rvalue_reference : public false_type {};
template<typename T> struct is_rvalue_reference<T&&> : public true_type {};

template<typename T>
struct is_reference : public disjunction<is_lvalue_reference<T>,
                                         is_rvalue_reference<T>>::type {};

// is_pointer
template<typename> struct _is_pointer_impl : public false_type {};
template<typename T> struct _is_pointer_impl<T*> : public true_type {};

template<typename T> struct is_pointer : public _is_pointer_impl<typename remove_cv<T>::type>::type {};

// is_null_pointer
template<typename> struct _is_null_pointer_impl : public false_type {};
template<> struct _is_null_pointer_impl<decltype(nullptr)> : public true_type {};
template<typename T> struct is_null_pointer : public _is_null_pointer_impl<typename remove_cv<T>::type>::type {};

// is_function
template<typename> struct is_function : public false_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...)> : public true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args......)> : public true_type {};

// is_void
template<typename> struct is_void : public false_type {};
template <> struct is_void<void> : public true_type {};

// is_integral
template<typename> struct _is_integral_impl : public false_type {};
template<> struct _is_integral_impl<bool> : public true_type {};
template<> struct _is_integral_impl<char> : public true_type {};
template<> struct _is_integral_impl<signed char> : public true_type {};
template<> struct _is_integral_impl<unsigned char> : public true_type {};
template<> struct _is_integral_impl<wchar_t> : public true_type {};
template<> struct _is_integral_impl<char16_t> : public true_type {};
template<> struct _is_integral_impl<char32_t> : public true_type {};
template<> struct _is_integral_impl<short> : public true_type {};
template<> struct _is_integral_impl<unsigned short> : public true_type {};
template<> struct _is_integral_impl<int> : public true_type {};
template<> struct _is_integral_impl<unsigned int> : public true_type {};
template<> struct _is_integral_impl<long> : public true_type {};
template<> struct _is_integral_impl<unsigned long> : public true_type {};
template<> struct _is_integral_impl<long long> : public true_type {};
template<> struct _is_integral_impl<unsigned long long> : public true_type {};

template<typename T> struct is_integral : public _is_integral_impl<typename remove_cv<T>::type>::type {};

// is_floating_point
template<typename> struct _is_floating_point_impl : public false_type { };
template<> struct _is_floating_point_impl<float> : public true_type {};
template<> struct _is_floating_point_impl<double> : public true_type {};
template<> struct _is_floating_point_impl<long double> : public true_type {};

template<typename T>
struct is_floating_point : public _is_floating_point_impl<typename remove_cv<T>::type>::type {};

// is_arithmetic
template<typename T>
struct is_arithmetic : public disjunction<is_integral<T>, is_floating_point<T>>::type {};

// is_fundamental
template<typename T>
struct is_fundamental
        : public disjunction<is_arithmetic<T>, is_void<T>,
                is_null_pointer<T>>::type
{};

// is_object
template<typename T>
struct is_object : public negation<disjunction<is_function<T>,
                                               is_reference<T>,
                                               is_void<T>>>::type {};

// is_array
template<typename T> struct is_array : public false_type {};
template<typename T> struct is_array<T[]> : public true_type {};
template<typename T, size_t N> struct is_array<T[N]> : public true_type {};

// is_signed
template<typename T, bool = is_arithmetic<T>::value> struct _is_signed_impl : public false_type {};
template<typename T> struct _is_signed_impl<T, true> : public bool_constant<T(-1) < T(0)> {};
template<typename T> struct is_signed : public _is_signed_impl<T>::type {};

// is_unsigned
template<typename T> struct is_unsigned : public conjunction<is_arithmetic<T>, negation<is_signed<T>>> {};

template<typename T, typename...> using erase_t = T;
template<typename...> using void_t = void;

// extent
template<typename, unsigned U>
struct extent : public integral_constant<std::size_t, 0> { };

template<typename T, unsigned U, std::size_t Size>
struct extent<T[Size], U> : public integral_constant<std::size_t, U == 0 ? Size : extent<T, U - 1>::value> {};

template<typename T, unsigned U>
struct extent<T[], U> : public integral_constant<std::size_t, U == 0 ? 0 : extent<T, U - 1>::value> {};

template<typename T>
struct _is_array_known_bounds : public integral_constant<bool, (extent<T>::value > 0)> {};

//template<typename T>
//struct _is_referenceable : public disjunction<is_object<T>, is_reference<T>>::type {};

#if __cpp_noexcept_function_type
#define LIBCXX_NOEXCEPT_PARM , bool _NE
#define LIBCXX_NOEXCEPT_QUAL noexcept (_NE)
#else
#define LIBCXX_NOEXCEPT_PARM
#define LIBCXX_NOEXCEPT_QUAL
#endif

template<typename T>
struct _is_referenceable : public disjunction<is_object<T>, is_reference<T>>::type {};

template<typename _Res, typename... _Args LIBCXX_NOEXCEPT_PARM>
struct _is_referenceable<_Res(_Args...) LIBCXX_NOEXCEPT_QUAL> : public true_type {};

template<typename _Res, typename... _Args LIBCXX_NOEXCEPT_PARM>
struct _is_referenceable<_Res(_Args......) LIBCXX_NOEXCEPT_QUAL> : public true_type {};

// is_constructible
namespace internal {
template<class, class T, class... Args> struct _is_constructible : std::false_type {};

template<class T, class... Args>
struct _is_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...> : std::true_type {};
}

template <class T, class... Args>
using is_constructible = internal::_is_constructible<void_t<>, T, Args...>;

// is_default_constructible
template<class T> struct is_default_constructible : public is_constructible<T> {};

// is_copy_constructible
template<class T> struct is_copy_constructible : public is_constructible<T, add_lvalue_reference_t<add_const_t<T>>> {};

// is_move_constructible
template <typename T> struct is_move_constructible : public is_constructible<T,add_rvalue_reference_t<T>> {};

template<typename T> struct _is_nt_def_ctorible_impl2 : public bool_constant<noexcept(T())> {};
template<typename T, bool = is_array<T>::value> struct _is_nt_def_ctorible_impl;

template<typename T>
struct _is_nt_def_ctorible_impl<T, true> : public conjunction<_is_array_known_bounds<T>,
        _is_nt_def_ctorible_impl2<typename remove_all_extents<T>::type>> {};

template<typename T>
struct _is_nt_def_ctorible_impl<T, false> : public _is_nt_def_ctorible_impl2<T> {};

// is_nothrow_default_constructible
template<typename T>
struct is_nothrow_default_constructible : public conjunction<is_default_constructible<T>, _is_nt_def_ctorible_impl<T>> {};

// is_nothrow_constructible
template<typename T, typename... Args>
struct _is_nt_ctorible_impl : public bool_constant<noexcept(T(declval<Args>()...))> {};

template<typename T, typename Arg>
struct _is_nt_ctorible_impl<T, Arg> : public bool_constant<noexcept(static_cast<T>(declval<Arg>()))> {};

template<typename T> struct _is_nt_ctorible_impl<T> : public is_nothrow_default_constructible<T> {};

template<typename T, typename...Args>
struct is_nothrow_constructible : public conjunction<is_constructible<T, Args...>, _is_nt_ctorible_impl<T, Args...>> {};

// is_nothrow_move_constructible
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_move_ctorible_impl;
template<typename T> struct _is_nt_move_ctorible_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_move_ctorible_impl<T, true> : public is_nothrow_constructible<T, T&&> {};
template<typename T> struct is_nothrow_move_constructible : public _is_nt_move_ctorible_impl<T> {};

// is_nothrow_copy_constructible
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_copy_ctorible_impl;
template<typename T> struct _is_nt_copy_ctorible_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_copy_ctorible_impl<T, true> : public is_nothrow_constructible<T, T const&> {};
template<typename T> struct is_nothrow_copy_constructible : public _is_nt_copy_ctorible_impl<T> {};

// is_destructible
template <typename T>
class _has_dtor
{
    template <typename T1> static true_type test(erase_t<int, decltype(declval<T1&>().~T1())>);
    template <typename T1> static false_type test(...);
  public:
    static const bool value = decltype(test<T>(12))::value;
};

template <typename T, bool> struct _is_destructible_impl;
template <typename T>
struct _is_destructible_impl<T, false> : public bool_constant<_has_dtor<typename remove_all_extents<T>::type>::value> {};
template <typename T> struct _is_destructible_impl<T, true> : public true_type {};

template <typename T, bool> struct _destructible_false;
template <typename T> struct _destructible_false<T, false> : public _is_destructible_impl<T, is_reference<T>::value> {};
template <typename T> struct _destructible_false<T, true> : public false_type {};
template <typename T> struct is_destructible : public _destructible_false<T, is_function<T>::value> {};
template <typename T> struct is_destructible<T[]> : public false_type {};
template <> struct is_destructible<void> : public false_type {};

// is_trivially_destructible
template<typename T> struct is_trivially_destructible : public bool_constant<__has_trivial_destructor(T)> {};
template<> struct is_trivially_destructible<void> : public true_type {};

// is_assignable
template<typename T, typename U>
struct is_assignable : public bool_constant<__is_assignable(T, U)> {};

// is_copy_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_copy_assignable_impl;
template<typename T> struct _is_copy_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_copy_assignable_impl<T, true> : public is_assignable<T&, const T&> {};
template<typename T> struct is_copy_assignable : public _is_copy_assignable_impl<T> {};

// is_move_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_move_assignable_impl;
template<typename T> struct _is_move_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_move_assignable_impl<T, true> : public is_assignable<T&, T&&> {};
template<typename T> struct is_move_assignable : public _is_move_assignable_impl<T> {};

// is_nothrow_assignable
template<typename T, typename U>
struct _is_nt_assignable_impl : public integral_constant<bool, noexcept(declval<T>() = declval<U>())> {};
template<typename T, typename U>
struct is_nothrow_assignable : public conjunction<is_assignable<T, U>, _is_nt_assignable_impl<T, U>> {};

// is_nothrow_copy_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_copy_assignable_impl;
template<typename T> struct _is_nt_copy_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_copy_assignable_impl<T, true> : public is_nothrow_assignable<T&, const T&> {};
template<typename T> struct is_nothrow_copy_assignable : public _is_nt_copy_assignable_impl<T> {};

// is_nothrow_move_assignable
template<typename T, bool = _is_referenceable<T>::value> struct _is_nt_move_assignable_impl;
template<typename T> struct _is_nt_move_assignable_impl<T, false> : public false_type {};
template<typename T> struct _is_nt_move_assignable_impl<T, true> : public is_nothrow_assignable<T&, T&&> {};
template<typename T> struct is_nothrow_move_assignable : public _is_nt_move_assignable_impl<T> {};

// is_same
template <typename, typename> struct is_same : public false_type {};
template <typename T> struct is_same<T, T> : public true_type {};

// is_base_of
template <typename Base, typename Derived>
struct is_base_of : public bool_constant<__is_base_of(Base, Derived)> {};

// is_convertible
template <typename From, typename To, bool = disjunction<is_void<From>, is_function<To>, is_array<To>>::value>
struct _is_convertible_helper { using type = typename is_void<To>::type; };

template <typename From, typename To>
class _is_convertible_helper<From, To, false>
{
    template<typename T> static void test_(T);
    template<typename F, typename T, typename = decltype(test_<T>(std::declval<F>()))> static true_type test(int);
    template<typename, typename> static false_type test(...);
  public:
    typedef decltype(test<From, To>(0)) type;
};

template <typename From, typename To> struct is_convertible : public _is_convertible_helper<From, To>::type {};

template <typename From, typename To = From>
class _is_swappable_impl
{
    template<typename U, typename V, typename = decltype(swap(declval<U&>(), declval<V&>()))> static true_type _test(int);
    template<typename, typename> static false_type _test(...);
  public:
    using type = decltype(_test<From, To>(0));
};

template <typename From, typename To = From>
class _is_nothrow_swappable_impl
{
    template<typename U, typename V> static bool_constant<noexcept(swap(declval<U&>(), declval<V&>()))> _test(int);
    template<typename, typename> static false_type _test(...);
  public:
    using type = decltype(_test<From, To>(0));
};

// is_swappable
template <typename T> struct is_swappable : public _is_swappable_impl<T>::type {};
template <typename T,typename U> struct is_swappable_with : public _is_swappable_impl<T, U>::type {};

// is_nothrow_swappable
template<typename T> struct is_nothrow_swappable : public _is_nothrow_swappable_impl<T>::type {};
template <typename T,typename U> struct is_nothrow_swappable_with : public _is_nothrow_swappable_impl<T, U>::type {};

// ====================================================
// Type properties (bool values)
// ====================================================
template <typename T1, typename T2> constexpr inline bool is_same_v = is_same<T1, T2>::value;
template <typename Base, typename Derived> constexpr inline bool is_base_of_v = is_base_of<Base, Derived>::value;
template <typename From, typename To> constexpr inline bool is_convertible_v = is_convertible<From, To>::value;

// See C++14 20.10.4.1, primary type categories
template <class T> inline constexpr bool is_void_v = is_void<T>::value;
template <class T> inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
template <class T> inline constexpr bool is_integral_v = is_integral<T>::value;
template <class T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;
template <class T> inline constexpr bool is_array_v = is_array<T>::value;
template <class T> inline constexpr bool is_pointer_v = is_pointer<T>::value;
template <class T> inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
template <class T> inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;
//template <class T> inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;
//template <class T> inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;
//template <class T> inline constexpr bool is_enum_v = is_enum<T>::value;
//template <class T> inline constexpr bool is_union_v = is_union<T>::value;
//template <class T> inline constexpr bool is_class_v = is_class<T>::value;
template <class T> inline constexpr bool is_function_v = is_function<T>::value;

// See C++14 20.10.4.2, composite type categories
template <class T> inline constexpr bool is_reference_v = is_reference<T>::value;
template <class T> inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
template <class T> inline constexpr bool is_fundamental_v = is_fundamental<T>::value;
template <class T> inline constexpr bool is_object_v = is_object<T>::value;
//template <class T> inline constexpr bool is_scalar_v = is_scalar<T>::value;
//template <class T> inline constexpr bool is_compound_v = is_compound<T>::value;
//template <class T> inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;
// See C++14 20.10.4.3, type properties
template <class T> inline constexpr bool is_const_v = is_const<T>::value;
//template <class T> inline constexpr bool is_volatile_v = is_volatile<T>::value;
//template <class T> inline constexpr bool is_trivial_v = is_trivial<T>::value;
//template <class T> inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;
//template <class T> inline constexpr bool is_standard_layout_v = is_standard_layout<T>::value;
//template <class T> inline constexpr bool is_pod_v = is_pod<T>::value;
//template <class T> inline constexpr bool is_literal_type_v = is_literal_type<T>::value;
//template <class T> inline constexpr bool is_empty_v = is_empty<T>::value;
//template <class T> inline constexpr bool is_polymorphic_v = is_polymorphic<T>::value;
//template <class T> inline constexpr bool is_abstract_v = is_abstract<T>::value;
//template <class T> inline constexpr bool is_final_v = is_final<T>::value;
//template <class T> inline constexpr bool is_aggregate_v = is_aggregate<T>::value;
template <class T> inline constexpr bool is_signed_v = is_signed<T>::value;
template <class T> inline constexpr bool is_unsigned_v = is_unsigned<T>::value;

template <class T, class... Args> inline constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
template <class T> inline constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
template <class T> inline constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;
template <class T> inline constexpr bool is_move_constructible_v = is_move_constructible<T>::value;
template <class T, class U> inline constexpr bool is_assignable_v = is_assignable<T, U>::value;
template <class T> inline constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;
template <class T> inline constexpr bool is_move_assignable_v = is_move_assignable<T>::value;
template <class T, class U> inline constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
template <class T> inline constexpr bool is_swappable_v = is_swappable<T>::value;
template <class T> inline constexpr bool is_destructible_v = is_destructible<T>::value;
//template <class T, class... Args> inline constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;
//template <class T> inline constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<T>::value;
//template <class T> inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<T>::value;
//template <class T> inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<T>::value;
//template <class T, class U> inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;
//template <class T> inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<T>::value;
//template <class T> inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;
template <class T> inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;
template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;
template <class T> inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<T>::value;
template <class T> inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<T>::value;
template <class T> inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<T>::value;
template <class T, class U> inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<T, U>::value;
template <class T> inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<T>::value;
template <class T> inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;
template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<T, U>::value;
template <class T> inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;
//template <class T> inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;
//template <class T> inline constexpr bool has_virtual_destructor_v = has_virtual_destructor<T>::value;

} // namespace std
